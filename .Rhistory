}
}
sea_ken_df$trend <- if_else(sea_ken_df$p_value >= .05 & !is.na(sea_ken_df$p_value), "Significant", "Insignificant")
attr(sea_ken_df, "sample_size") <- sample_size
return(sea_ken_df)
}
seaKen <- sea_ken(filter(clack_data, MLocID %in% c(temp_trend$MLocID, pH_trend$MLocID)))
print(tmp_sample_size)
colnames(tmp_sample_size)
sample_size <- bind_rows(sample_size, tmp_sample_size)
sample_size
sea_ken <- function(data){
data$Month <- lubridate::month(data$sample_datetime, abbr = TRUE)
data$Year <- lubridate::year(data$sample_datetime)
sea_ken_df <- data.frame()
sample_size <- data.frame()
for(j in unique(data$Char_Name)){
print(j)
subData <- filter(data, Char_Name == j)
for(i in unique(subData$MLocID)){
print(i)
subData_stn <- subData %>% filter(MLocID == i)
tmp_seaKen <- EnvStats::kendallSeasonalTrendTest(Result_Numeric ~ Month + Year, data = subData_stn)
tmp_sample_size <- as.data.frame(bind_rows(tmp_seaKen$sample.size))
tmp_sample_size[, c("ID", "Char")] <- c(i, j)
print(tmp_sample_size)
stn_seaKen <- data.frame(MLocID = i,
Char_Name = j,
p_value = tmp_seaKen$p.value[1],
confidence = tmp_seaKen$interval$conf.level,
slope = tmp_seaKen$estimate[2],
intercept = tmp_seaKen$estimate[3])
sample_size <- bind_rows(sample_size, tmp_sample_size)
sea_ken_df <- bind_rows(sea_ken_df, stn_seaKen)
}
}
sea_ken_df$trend <- if_else(sea_ken_df$p_value >= .05 & !is.na(sea_ken_df$p_value), "Significant", "Insignificant")
attr(sea_ken_df, "sample_size") <- sample_size
return(sea_ken_df)
}
seaKen <- sea_ken(filter(clack_data, MLocID %in% c(temp_trend$MLocID, pH_trend$MLocID)))
data <- filter(clack_data, MLocID %in% c(temp_trend$MLocID, pH_trend$MLocID))
data$Month <- lubridate::month(data$sample_datetime, abbr = TRUE)
data$Year <- lubridate::year(data$sample_datetime)
View(data)
data$Month <- lubridate::month(data$sample_datetime, label = TRUE, abbr = TRUE)
View(data)
sea_ken <- function(data){
data$Month <- lubridate::month(data$sample_datetime, label = TRUE, abbr = TRUE)
data$Year <- lubridate::year(data$sample_datetime)
sea_ken_df <- data.frame()
sample_size <- data.frame()
for(j in unique(data$Char_Name)){
print(j)
subData <- filter(data, Char_Name == j)
for(i in unique(subData$MLocID)){
print(i)
subData_stn <- subData %>% filter(MLocID == i)
tmp_seaKen <- EnvStats::kendallSeasonalTrendTest(Result_Numeric ~ Month + Year, data = subData_stn)
tmp_sample_size <- as.data.frame(bind_rows(tmp_seaKen$sample.size))
tmp_sample_size[, c("ID", "Char")] <- c(i, j)
print(tmp_sample_size)
stn_seaKen <- data.frame(MLocID = i,
Char_Name = j,
p_value = tmp_seaKen$p.value[1],
confidence = tmp_seaKen$interval$conf.level,
slope = tmp_seaKen$estimate[2],
intercept = tmp_seaKen$estimate[3])
sample_size <- bind_rows(sample_size, tmp_sample_size)
sea_ken_df <- bind_rows(sea_ken_df, stn_seaKen)
}
}
sea_ken_df$trend <- if_else(sea_ken_df$p_value >= .05 & !is.na(sea_ken_df$p_value), "Significant", "Insignificant")
attr(sea_ken_df, "sample_size") <- sample_size
return(sea_ken_df)
}
seaKen <- sea_ken(filter(clack_data, MLocID %in% c(temp_trend$MLocID, pH_trend$MLocID)))
View(attributes(seaKen)$sample_size)
sea_ken <- function(data){
data$Month <- lubridate::month(data$sample_datetime, label = TRUE, abbr = TRUE)
data$Year <- lubridate::year(data$sample_datetime)
sea_ken_df <- data.frame()
sample_size <- data.frame()
for(j in unique(data$Char_Name)){
print(j)
subData <- filter(data, Char_Name == j)
for(i in unique(subData$MLocID)){
print(i)
subData_stn <- subData %>% filter(MLocID == i)
tmp_seaKen <- EnvStats::kendallSeasonalTrendTest(Result_Numeric ~ Month + Year, data = subData_stn)
tmp_sample_size <- as.data.frame(bind_rows(tmp_seaKen$sample.size))
tmp_sample_size[, c("ID", "Char")] <- c(i, j)
print(tmp_sample_size)
stn_seaKen <- data.frame(MLocID = i,
Char_Name = j,
p_value = tmp_seaKen$p.value[1],
confidence = tmp_seaKen$interval$conf.level,
slope = tmp_seaKen$estimate[2],
intercept = tmp_seaKen$estimate[3])
sample_size <- bind_rows(sample_size, tmp_sample_size)
sea_ken_df <- bind_rows(sea_ken_df, stn_seaKen)
}
}
sea_ken_df$trend <- if_else(sea_ken_df$p_value >= .05 & !is.na(sea_ken_df$p_value), "Significant", "Insignificant")
attr(sea_ken_df, "sample_size") <- sample_size[, c('ID', 'Char', 'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul',
'Aug', 'Sep', 'Oct', 'Nov', 'Dec', 'Total')]
return(sea_ken_df)
}
seaKen <- sea_ken(filter(clack_data, MLocID %in% c(temp_trend$MLocID, pH_trend$MLocID)))
seaKen_sample_size <- attributes(seaKen)$sample_size
View(seaKen_sample_size)
pH_plots[1]
pH_plots[2]
pH_plots[3]
pH_plots[4]
plot_pH <- function(data, seaKen, station){
# obtain data range limits for plotting
xmin <- min(data$sample_datetime, na.rm = TRUE)
xmax <- max(data$sample_datetime, na.rm = TRUE)
ymin <- min(c(data$Result_Numeric, data$temp_crit), na.rm = TRUE)
ymax <- max(c(data$Result_Numeric, data$temp_crit), na.rm = TRUE)
data$excursion <- if_else(data$pH_excursion == 1, "Excursion", "Result") # change numeric value to descriptor
# obtain plotting values for trend line if applicable
if(station %in% seaKen$MLocID){
slope <- seaKen[seaKen$MLocID == station & seaKen$Char_Name == "pH", "slope"]
x_delta <- as.numeric((xmax-xmin)/2)
y_median <- median(data$Result_Numeric, na.rm = TRUE)
sk_min <- y_median - x_delta*slope/365.25
sk_max <- y_median + x_delta*slope/365.25
}
p <- ggplot(data)
# add pH min and max criteria lines
p <- p + geom_segment(aes(x=xmin, xend=xmax, y=pH_Min, yend=pH_Min,
color = "pH Minimum Criteria", linetype = "pH Minimum Criteria", shape = "pH Minimum Criteria"))
p <- p + geom_segment(aes(x=xmin, xend=xmax, y=pH_Max, yend=pH_Max,
color = "pH Maximum Criteria", linetype = "pH Maximum Criteria", shape = "pH Maximum Criteria"))
# plot data with excursion colors
p <- p + geom_point(aes(x=sample_datetime, y=Result_Numeric, color = excursion, linetype = excursion, shape = excursion)) +
ggtitle(paste(station)) +
ylab("pH") +
xlab("Datetime")
# plot the trend line if applicable
if(station %in% seaKen$MLocID){
p <- p + geom_segment(aes(x=xmin, xend=xmax, y=sk_min, yend=sk_max, color = "Trend", linetype = "Trend", shape = "Trend"))
}
# apply color, shape, line types, and range limits
p <- p +
scale_color_manual(name = "Legend",
values =    c('Excursion' = 'red', 'Result' = 'black', "Trend" = 'blue')) +
scale_linetype_manual(name = "Legend",
values = c('Excursion' = 0, 'Result' = 0, "Trend" = 1)) +
scale_shape_manual(name = "Legend",
values =    c('Excursion' = 16, 'Result' = 16, "Trend" = 32)) +
ylim(c(ymin, ymax)) +
xlim(c(xmin, xmax)) +
theme(legend.position="bottom", legend.direction = "horizontal", legend.box = "horizontal")
return(p)
}
pH_stations <- unique(c(pH_status[pH_status$Char_Name == "pH",]$MLocID, seaKen[seaKen$Char_Name == "pH",]$MLocID))
pH_plots <- list()
for(i in pH_stations){
plot_data <- clack_data_pH %>% filter(Char_Name == "pH", MLocID == i)
p <- plot_pH(plot_data, seaKen, i)
pH_plots[[i]] <- p
}
pH_plots[2]
plot_pH <- function(data, seaKen, station){
# obtain data range limits for plotting
xmin <- min(data$sample_datetime, na.rm = TRUE)
xmax <- max(data$sample_datetime, na.rm = TRUE)
ymin <- min(c(data$Result_Numeric, data$temp_crit), na.rm = TRUE)
ymax <- max(c(data$Result_Numeric, data$temp_crit), na.rm = TRUE)
data$excursion <- if_else(data$pH_excursion == 1, "Excursion", "Result") # change numeric value to descriptor
# obtain plotting values for trend line if applicable
if(station %in% seaKen$MLocID){
slope <- seaKen[seaKen$MLocID == station & seaKen$Char_Name == "pH", "slope"]
x_delta <- as.numeric((xmax-xmin)/2)
y_median <- median(data$Result_Numeric, na.rm = TRUE)
sk_min <- y_median - x_delta*slope/365.25
sk_max <- y_median + x_delta*slope/365.25
}
p <- ggplot(data)
# add pH min and max criteria lines
p <- p + geom_segment(aes(x=xmin, xend=xmax, y=pH_Min, yend=pH_Min,
color = "pH Minimum Criteria", linetype = "pH Minimum Criteria", shape = "pH Minimum Criteria"))
p <- p + geom_segment(aes(x=xmin, xend=xmax, y=pH_Max, yend=pH_Max,
color = "pH Maximum Criteria", linetype = "pH Maximum Criteria", shape = "pH Maximum Criteria"))
# plot data with excursion colors
p <- p + geom_point(aes(x=sample_datetime, y=Result_Numeric, color = excursion, linetype = excursion, shape = excursion)) +
ggtitle(paste(station)) +
ylab("pH") +
xlab("Datetime")
# plot the trend line if applicable
if(station %in% seaKen$MLocID){
p <- p + geom_segment(aes(x=xmin, xend=xmax, y=sk_min, yend=sk_max, color = "Trend", linetype = "Trend", shape = "Trend"))
}
# apply color, shape, line types, and range limits
p <- p +
scale_color_manual(name = "Legend",
values =    c('Excursion' = 'red', 'Result' = 'black', "Trend" = 'blue',
"pH Minimum Criteria" = 'black', 'pH Maximum Criteria' = 'black')) +
scale_linetype_manual(name = "Legend",
values = c('Excursion' = 0, 'Result' = 0, "Trend" = 1,
"pH Minimum Criteria" = '2', 'pH Maximum Criteria' = '2')) +
scale_shape_manual(name = "Legend",
values =    c('Excursion' = 16, 'Result' = 16, "Trend" = 32,
"pH Minimum Criteria" = '32', 'pH Maximum Criteria' = '32')) +
ylim(c(ymin, ymax)) +
xlim(c(xmin, xmax)) +
theme(legend.position="bottom", legend.direction = "horizontal", legend.box = "horizontal")
return(p)
}
pH_stations <- unique(c(pH_status[pH_status$Char_Name == "pH",]$MLocID, seaKen[seaKen$Char_Name == "pH",]$MLocID))
pH_plots <- list()
for(i in pH_stations){
plot_data <- clack_data_pH %>% filter(Char_Name == "pH", MLocID == i)
p <- plot_pH(plot_data, seaKen, i)
pH_plots[[i]] <- p
}
pH_plots[2]
plot_pH <- function(data, seaKen, station){
# obtain data range limits for plotting
xmin <- min(data$sample_datetime, na.rm = TRUE)
xmax <- max(data$sample_datetime, na.rm = TRUE)
ymin <- min(c(data$Result_Numeric, data$temp_crit), na.rm = TRUE)
ymax <- max(c(data$Result_Numeric, data$temp_crit), na.rm = TRUE)
data$excursion <- if_else(data$pH_excursion == 1, "Excursion", "Result") # change numeric value to descriptor
# obtain plotting values for trend line if applicable
if(station %in% seaKen$MLocID){
slope <- seaKen[seaKen$MLocID == station & seaKen$Char_Name == "pH", "slope"]
x_delta <- as.numeric((xmax-xmin)/2)
y_median <- median(data$Result_Numeric, na.rm = TRUE)
sk_min <- y_median - x_delta*slope/365.25
sk_max <- y_median + x_delta*slope/365.25
}
p <- ggplot(data)
# add pH min and max criteria lines
p <- p + geom_segment(aes(x=xmin, xend=xmax, y=pH_Min, yend=pH_Min,
color = "pH Minimum Criteria", linetype = "pH Minimum Criteria", shape = "pH Minimum Criteria"))
p <- p + geom_segment(aes(x=xmin, xend=xmax, y=pH_Max, yend=pH_Max,
color = "pH Maximum Criteria", linetype = "pH Maximum Criteria", shape = "pH Maximum Criteria"))
# plot data with excursion colors
p <- p + geom_point(aes(x=sample_datetime, y=Result_Numeric, color = excursion, linetype = excursion, shape = excursion)) +
ggtitle(paste(station)) +
ylab("pH") +
xlab("Datetime")
# plot the trend line if applicable
if(station %in% seaKen$MLocID){
p <- p + geom_segment(aes(x=xmin, xend=xmax, y=sk_min, yend=sk_max, color = "Trend", linetype = "Trend", shape = "Trend"))
}
# apply color, shape, line types, and range limits
p <- p +
scale_color_manual(name = "Legend",
values =    c('Excursion' = 'red', 'Result' = 'black', "Trend" = 'blue',
"pH Minimum Criteria" = 'black', 'pH Maximum Criteria' = 'black')) +
scale_linetype_manual(name = "Legend",
values = c('Excursion' = 0, 'Result' = 0, "Trend" = 1,
"pH Minimum Criteria" = 2, 'pH Maximum Criteria' = 2)) +
scale_shape_manual(name = "Legend",
values =    c('Excursion' = 16, 'Result' = 16, "Trend" = 32,
"pH Minimum Criteria" = 32, 'pH Maximum Criteria' = 32)) +
ylim(c(ymin, ymax)) +
xlim(c(xmin, xmax)) +
theme(legend.position="bottom", legend.direction = "horizontal", legend.box = "horizontal")
return(p)
}
pH_stations <- unique(c(pH_status[pH_status$Char_Name == "pH",]$MLocID, seaKen[seaKen$Char_Name == "pH",]$MLocID))
pH_plots <- list()
for(i in pH_stations){
plot_data <- clack_data_pH %>% filter(Char_Name == "pH", MLocID == i)
p <- plot_pH(plot_data, seaKen, i)
pH_plots[[i]] <- p
}
pH_plots[2]
plot_pH <- function(data, seaKen, station){
# obtain data range limits for plotting
xmin <- min(data$sample_datetime, na.rm = TRUE)
xmax <- max(data$sample_datetime, na.rm = TRUE)
ymin <- min(c(data$Result_Numeric, data$pH_Min), na.rm = TRUE)
ymax <- max(c(data$Result_Numeric, data$pH_Max), na.rm = TRUE)
data$excursion <- if_else(data$pH_excursion == 1, "Excursion", "Result") # change numeric value to descriptor
# obtain plotting values for trend line if applicable
if(station %in% seaKen$MLocID){
slope <- seaKen[seaKen$MLocID == station & seaKen$Char_Name == "pH", "slope"]
x_delta <- as.numeric((xmax-xmin)/2)
y_median <- median(data$Result_Numeric, na.rm = TRUE)
sk_min <- y_median - x_delta*slope/365.25
sk_max <- y_median + x_delta*slope/365.25
}
p <- ggplot(data)
# add pH min and max criteria lines
p <- p + geom_segment(aes(x=xmin, xend=xmax, y=pH_Min, yend=pH_Min,
color = "pH Criteria", linetype = "pH Criteria", shape = "pH Criteria"))
p <- p + geom_segment(aes(x=xmin, xend=xmax, y=pH_Max, yend=pH_Max,
color = "pH Criteria", linetype = "pH Criteria", shape = "pH Criteria"))
# plot data with excursion colors
p <- p + geom_point(aes(x=sample_datetime, y=Result_Numeric, color = excursion, linetype = excursion, shape = excursion)) +
ggtitle(paste(station, "pH")) +
ylab("pH") +
xlab("Datetime")
# plot the trend line if applicable
if(station %in% seaKen$MLocID){
p <- p + geom_segment(aes(x=xmin, xend=xmax, y=sk_min, yend=sk_max, color = "Trend", linetype = "Trend", shape = "Trend"))
}
# apply color, shape, line types, and range limits
p <- p +
scale_color_manual(name = "Legend",
values =    c('Excursion' = 'red', 'Result' = 'black', "Trend" = 'blue', "pH Criteria" = 'black')) +
scale_linetype_manual(name = "Legend",
values = c('Excursion' = 0, 'Result' = 0, "Trend" = 1, "pH Criteria" = 2)) +
scale_shape_manual(name = "Legend",
values =    c('Excursion' = 16, 'Result' = 16, "Trend" = 32, "pH Criteria" = 32)) +
ylim(c(ymin, ymax)) +
xlim(c(xmin, xmax)) +
theme(legend.position="bottom", legend.direction = "horizontal", legend.box = "horizontal")
return(p)
}
pH_stations <- unique(c(pH_status[pH_status$Char_Name == "pH",]$MLocID, seaKen[seaKen$Char_Name == "pH",]$MLocID))
pH_plots <- list()
for(i in pH_stations){
plot_data <- clack_data_pH %>% filter(Char_Name == "pH", MLocID == i)
p <- plot_pH(plot_data, seaKen, i)
pH_plots[[i]] <- p
}
pH_plots[2]
pH_plots[1]
pH_plots[2]
pH_plots[3]
pH_plots[4]
pH_plots[5]
getwd()
setwd('//deqhq1/wqnps/Agriculture/Status_and_Trend_Analysis/StatusAndTrends_Package/odeqstatusandtrends')
document()
devtools::document
devtools::document()
devtools::document()
AWQMSdata::AWQMS_Data(startdate = "2000-01-01", char = "Mercury")
sea_ken <- function(data){
data$Month <- lubridate::month(data$sample_datetime, label = TRUE, abbr = TRUE)
data$Year <- lubridate::year(data$sample_datetime)
sea_ken_df <- data.frame()
sample_size <- data.frame()
for(j in unique(data$Char_Name)){
print(j)
subData <- filter(data, Char_Name == j)
for(i in unique(subData$MLocID)){
print(i)
subData_stn <- subData %>% filter(MLocID == i)
tmp_seaKen <- EnvStats::kendallSeasonalTrendTest(Result_Numeric ~ Month + Year, data = subData_stn)
tmp_sample_size <- as.data.frame(bind_rows(tmp_seaKen$sample.size))
tmp_sample_size[, c("ID", "Char")] <- c(i, j)
print(tmp_sample_size)
stn_seaKen <- data.frame(MLocID = i,
Char_Name = j,
p_value = tmp_seaKen$p.value[1],
confidence = tmp_seaKen$interval$conf.level,
slope = tmp_seaKen$estimate[2],
intercept = tmp_seaKen$estimate[3])
sample_size <- bind_rows(sample_size, tmp_sample_size)
sea_ken_df <- bind_rows(sea_ken_df, stn_seaKen)
}
}
sea_ken_df$significance <- if_else(sea_ken_df$p_value >= .05 & !is.na(sea_ken_df$p_value), "Significant", "Insignificant")
sea_ken_df$trend <- if_else(sea_ken_df$slope > 0 & sea_ken_df$p_value >= .05, "Increasing",
if_else(sea_ken_df$slope < 0 & sea_ken_df$p_value >= .05, "Decreasing",
if_else(sea_ken_df$slope = 0 & sea_ken_df$p_value >= .05, "Steady", "No Significant Trend")
)
)
attr(sea_ken_df, "sample_size") <- sample_size[, c('ID', 'Char', 'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul',
'Aug', 'Sep', 'Oct', 'Nov', 'Dec', 'Total')]
return(sea_ken_df)
}
sea_ken <- function(data){
data$Month <- lubridate::month(data$sample_datetime, label = TRUE, abbr = TRUE)
data$Year <- lubridate::year(data$sample_datetime)
sea_ken_df <- data.frame()
sample_size <- data.frame()
for(j in unique(data$Char_Name)){
print(j)
subData <- filter(data, Char_Name == j)
for(i in unique(subData$MLocID)){
print(i)
subData_stn <- subData %>% filter(MLocID == i)
tmp_seaKen <- EnvStats::kendallSeasonalTrendTest(Result_Numeric ~ Month + Year, data = subData_stn)
tmp_sample_size <- as.data.frame(bind_rows(tmp_seaKen$sample.size))
tmp_sample_size[, c("ID", "Char")] <- c(i, j)
print(tmp_sample_size)
stn_seaKen <- data.frame(MLocID = i,
Char_Name = j,
p_value = tmp_seaKen$p.value[1],
confidence = tmp_seaKen$interval$conf.level,
slope = tmp_seaKen$estimate[2],
intercept = tmp_seaKen$estimate[3])
sample_size <- bind_rows(sample_size, tmp_sample_size)
sea_ken_df <- bind_rows(sea_ken_df, stn_seaKen)
}
}
sea_ken_df$significance <- if_else(sea_ken_df$p_value >= .05 & !is.na(sea_ken_df$p_value), "Significant", "Insignificant")
sea_ken_df$trend <- if_else(sea_ken_df$slope > 0 & sea_ken_df$p_value >= .05, "Increasing",
if_else(sea_ken_df$slope < 0 & sea_ken_df$p_value >= .05, "Decreasing",
if_else(sea_ken_df$slope == 0 & sea_ken_df$p_value >= .05, "Steady", "No Significant Trend")
)
)
attr(sea_ken_df, "sample_size") <- sample_size[, c('ID', 'Char', 'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul',
'Aug', 'Sep', 'Oct', 'Nov', 'Dec', 'Total')]
return(sea_ken_df)
}
seaKen <- sea_ken(filter(clack_data, MLocID %in% c(temp_trend$MLocID, pH_trend$MLocID)))
View(seaKen)
sea_ken <- function(data){
data$Month <- lubridate::month(data$sample_datetime, label = TRUE, abbr = TRUE)
data$Year <- lubridate::year(data$sample_datetime)
sea_ken_df <- data.frame()
sample_size <- data.frame()
for(j in unique(data$Char_Name)){
print(j)
subData <- filter(data, Char_Name == j)
for(i in unique(subData$MLocID)){
print(i)
subData_stn <- subData %>% filter(MLocID == i)
tmp_seaKen <- EnvStats::kendallSeasonalTrendTest(Result_Numeric ~ Month + Year, data = subData_stn)
tmp_sample_size <- as.data.frame(bind_rows(tmp_seaKen$sample.size))
tmp_sample_size[, c("ID", "Char")] <- c(i, j)
print(tmp_sample_size)
stn_seaKen <- data.frame(MLocID = i,
Char_Name = j,
p_value = tmp_seaKen$p.value[1],
confidence = tmp_seaKen$interval$conf.level,
slope = tmp_seaKen$estimate[2],
intercept = tmp_seaKen$estimate[3])
sample_size <- bind_rows(sample_size, tmp_sample_size)
sea_ken_df <- bind_rows(sea_ken_df, stn_seaKen)
}
}
sea_ken_df$significance <- if_else(sea_ken_df$p_value >= .05 & !is.na(sea_ken_df$p_value), "Significant", "Insignificant")
sea_ken_df$trend <-
if_else(sea_ken_df$slope > 0 & sea_ken_df$significance == "Significant", "Increasing",
if_else(sea_ken_df$slope < 0 & sea_ken_df$significance == "Significant", "Decreasing",
if_else(sea_ken_df$slope == 0 & sea_ken_df$significance == "Significant", "Steady", "No Significant Trend")
)
)
attr(sea_ken_df, "sample_size") <- sample_size[, c('ID', 'Char', 'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul',
'Aug', 'Sep', 'Oct', 'Nov', 'Dec', 'Total')]
return(sea_ken_df)
}
seaKen <- sea_ken(filter(clack_data, MLocID %in% c(temp_trend$MLocID, pH_trend$MLocID)))
View(seaKen)
seaKen_sample_size <- attributes(seaKen)$sample_size
View(seaKen_sample_size)
View(temp_trend)
View(pH_trend)
trend <- bind_rows(pH_trend, temp_trend)
View(trend)
status <- bind_rows(pH_status, temp_status)
View(status)
getwd()
document()
devtools::document()
devtools::install_github('https://github.com/donco/odeqstatusandtrends')
# devtools::install_github('https://github.com/donco/odeqstatusandtrends')
library(odeqstatusandtrends)
start.date = "2000-01-01"
end.date = "2019-01-01"
Name <- "Clackamas"
# support_files_dir <- "//deqhq1/GISLIBRARY/Base_Data/Hydrography/Watershed_Boundaries/WBD_OR.gdb/WBD_OR.gdb/WBD_OR"
basin_shp <- readOGR(dsn = "//deqhq1/GISLIBRARY/Base_Data/Hydrography/Watershed_Boundaries/WBD_OR.gdb/WBD_OR.gdb",
layer = 'WBD_HU8', integer64="warn.loss", verbose = FALSE)
basin_shp <- basin_shp[basin_shp$HU_8_NAME == "Clackamas", ]
clack_stations_AWQMS <- get_stations_AWQMS(basin_shp)
# ss_stations_NWIS <- get_stations_NWIS(agwqma_shp)
clack_data_raw <- GetData(parameters = c("Temperature", "Bacteria", "TSS", "DO", "TP", "pH"),
stations_AWQMS = clack_stations_AWQMS,
# stations_NWIS = ss_stations_NWIS,
start.date = start.date,
end.date = end.date)
clack_data <- CleanData(clack_data_raw)
clack_data <- add_criteria(clack_data)
clack_data_pH <- clack_data %>% filter(Char_Name == "pH")
clack_data_pH <- Censored_data(clack_data_pH, criteria = 'pH_Min')
clack_data_pH <- pH_assessment(clack_data_pH)
# clack_data_ph$exceed <- ifelse(clack_data_ph$Result_Numeric >= clack_data_ph$pH_crit_min & clack_data_ph$Result_Numeric <= clack_data_ph$pH_crit_max, FALSE, TRUE)
# clack_data_ph <- clack_data_ph %>% filter(!is.na(exceed))
clack_data_temp <- clack_data %>% filter(Char_Name == "Temperature, water")
clack_data_temp <- Censored_data(clack_data_temp, criteria = "temp_crit")
clack_data_temp <- temp_assessment(clack_data_temp)
# clack_data_temp$exceed <- ifelse(clack_data_temp$Result_Numeric >= clack_data_temp$temp_crit, TRUE, FALSE)
# clack_data_temp <- clack_data_temp %>% filter(!is.na(exceed))
clack_data <- bind_rows(clack_data_temp, clack_data_pH)
pH_status <- status_stns(clack_data_pH)
temp_status <- status_stns(clack_data_temp)
status <- bind_rows(pH_status, temp_status)
pH_trend <- trend_stns(clack_data_pH)
temp_trend <- trend_stns(clack_data_temp)
trend <- bind_rows(pH_trend, temp_trend)
seaKen <- sea_ken(filter(clack_data, MLocID %in% c(temp_trend$MLocID, pH_trend$MLocID)))
seaKen_sample_size <- attributes(seaKen)$sample_size
temp_stations <- unique(c(status[status$Char_Name == "Temperature, water",]$MLocID, seaKen[seaKen$Char_Name == "Temperature, water",]$MLocID))
temp_plots <- list()
for(i in temp_stations){
plot_data <- clack_data_temp %>% filter(Char_Name == "Temperature, water", MLocID == i)
p <- plot_temperature(plot_data, seaKen, i)
temp_plots[[i]] <- p
}
temp_plots[2]
pH_stations <- unique(c(status[status$Char_Name == "pH",]$MLocID, seaKen[seaKen$Char_Name == "pH",]$MLocID))
pH_plots <- list()
for(i in pH_stations){
plot_data <- clack_data_pH %>% filter(Char_Name == "pH", MLocID == i)
p <- plot_pH(plot_data, seaKen, i)
pH_plots[[i]] <- p
}
pH_plots[2]
