ggtitle(paste(station)) +
ylab("Temperature (degrees C)") +
xlab("Datetime")
if(station %in% seaKen$MLocID){
p <- p + geom_segment(aes(x=x_min, xend=x_max, y=sk_min, yend=sk_max, color = "Trend", linetype = "Trend", shape = "Trend"))
}
if(any(!is.na(data$temp_crit))){
p <- p + geom_line(aes(x=sample_datetime, y=temp_crit, color=Spawn_type, linetype=Spawn_type, shape=Spawn_type))
}
if(any(data$Spawn_type == "Spawn")){
p <- p + geom_line(aes(x=sample_datetime, y=spawning_crit, color=Spawn_type, linetype=Spawn_type, shape=Spawn_type))
}
# p <- p +
#   scale_color_manual(values = c('1' = 'red', '0' = 'black', "Trend" = 'blue', "Spawn" = 'black', "Not_Spawn" = 'black')) +
#   scale_linetype_manual(values = c('1' = 0, '0' = 0, "Trend" = 1, "Spawn" = 2, "Not_Spawn" = 3)) +
#   scale_shape_manual(values = c('1' = 16, '0' = 16, "Trend" = 32, "Spawn" = 32, "Not_Spawn" = 32)) +
#   ylim(c(ymin, ymax))
return(p)
}
temp_plots <- list()
for(i in temp_stations){
plot_data <- clack_data_temp %>% filter(Char_Name == "Temperature, water", MLocID == i)
p <- plot_temperature(plot_data, seaKen, i)
temp_plots[[i]] <- p
}
temp_plots[1]
data <- plot_data
if(station %in% seaKen$MLocID){
slope <- seaKen[seaKen$MLocID == station & seaKen$Char_Name == "Temperature, water", "slope"]
x_min <- min(data$sample_datetime, na.rm = TRUE)
x_max <- max(data$sample_datetime, na.rm = TRUE)
x_delta <- as.numeric((x_max-x_min)/2)
y_median <- median(data$Result_Numeric, na.rm = TRUE)
sk_min <- y_median - x_delta*slope/365.25
sk_max <- y_median + x_delta*slope/365.25
}
ymin <- min(c(data$Result_Numeric, data$temp_crit), na.rm = TRUE)
ymax <- max(c(data$Result_Numeric, data$temp_crit), na.rm = TRUE)
data$excursion <- as.character(data$excursion)
p <- ggplot(data)
p
any(data$Spawn_type == "Spawn")
plot_data$Start_spawn <- as.POSIXct(plot_data$Start_spawn)
plot_data$End_spawn <- as.POSIXct(plot_data$End_spawn)
rects <- unique(plot_data[,c("Start_spawn", "End_spawn")])
data$Start_spawn <- as.POSIXct(data$Start_spawn)
data$End_spawn <- as.POSIXct(data$End_spawn)
rects <- unique(data[,c("Start_spawn", "End_spawn")])
rects$ymin <- -Inf
rects$ymax <- Inf
p + geom_rect(data = rects, aes(xmin=Start_spawn, xmax=End_spawn, ymin=ymin, ymax=ymax), color = 'grey', alpha=.2, fill='black')
p + geom_point(aes(x=sample_datetime, y=Result_Numeric, color = excursion, linetype = excursion, shape = excursion)) +
ggtitle(paste(station)) +
ylab("Temperature (degrees C)") +
xlab("Datetime")
if(station %in% seaKen$MLocID){
p <- p + geom_segment(aes(x=x_min, xend=x_max, y=sk_min, yend=sk_max, color = "Trend", linetype = "Trend", shape = "Trend"))
}
if(any(!is.na(data$temp_crit))){
p <- p + geom_line(aes(x=sample_datetime, y=temp_crit, color=Spawn_type, linetype=Spawn_type, shape=Spawn_type))
}
if(any(data$Spawn_type == "Spawn")){
p <- p + geom_line(aes(x=sample_datetime, y=spawning_crit, color=Spawn_type, linetype=Spawn_type, shape=Spawn_type))
}
p
plot_temperature <- function(data, seaKen, station){
if(station %in% seaKen$MLocID){
slope <- seaKen[seaKen$MLocID == station & seaKen$Char_Name == "Temperature, water", "slope"]
x_min <- min(data$sample_datetime, na.rm = TRUE)
x_max <- max(data$sample_datetime, na.rm = TRUE)
x_delta <- as.numeric((x_max-x_min)/2)
y_median <- median(data$Result_Numeric, na.rm = TRUE)
sk_min <- y_median - x_delta*slope/365.25
sk_max <- y_median + x_delta*slope/365.25
}
ymin <- min(c(data$Result_Numeric, data$temp_crit), na.rm = TRUE)
ymax <- max(c(data$Result_Numeric, data$temp_crit), na.rm = TRUE)
data$excursion <- as.character(data$excursion)
p <- ggplot(data)
if(any(data$Spawn_type == "Spawn")){
# spawn_start <- as.POSIXct(unique(data$spawn_start), format = "%m/%d")
# spawn_end <- as.POSIXct(unique(data$spawn_end), format = "%m/%d")
# years <- unique(lubridate::year(data$sample_datetime))
# rects <- data.frame(x1=as.POSIXct(paste0(years, "-", lubridate::month(spawn_start), "-", lubridate::day(spawn_start))),
#                     x2=as.POSIXct(paste0(years, "-", lubridate::month(spawn_end), "-", lubridate::day(spawn_end))),
#                     y1=-Inf, y2=Inf)
data$Start_spawn <- as.POSIXct(data$Start_spawn)
data$End_spawn <- as.POSIXct(data$End_spawn)
rects <- unique(data[,c("Start_spawn", "End_spawn")])
rects$ymin <- -Inf
rects$ymax <- Inf
p + geom_rect(data = rects, aes(xmin=Start_spawn, xmax=End_spawn, ymin=ymin, ymax=ymax), color = 'grey', alpha=.2, fill='black')
}
p <- p + geom_point(aes(x=sample_datetime, y=Result_Numeric, color = excursion, linetype = excursion, shape = excursion)) +
ggtitle(paste(station)) +
ylab("Temperature (degrees C)") +
xlab("Datetime")
if(station %in% seaKen$MLocID){
p <- p + geom_segment(aes(x=x_min, xend=x_max, y=sk_min, yend=sk_max, color = "Trend", linetype = "Trend", shape = "Trend"))
}
if(any(!is.na(data$temp_crit))){
p <- p + geom_line(aes(x=sample_datetime, y=temp_crit, color=Spawn_type, linetype=Spawn_type, shape=Spawn_type))
}
if(any(data$Spawn_type == "Spawn")){
p <- p + geom_line(aes(x=sample_datetime, y=spawning_crit, color=Spawn_type, linetype=Spawn_type, shape=Spawn_type))
}
# p <- p +
#   scale_color_manual(values = c('1' = 'red', '0' = 'black', "Trend" = 'blue', "Spawn" = 'black', "Not_Spawn" = 'black')) +
#   scale_linetype_manual(values = c('1' = 0, '0' = 0, "Trend" = 1, "Spawn" = 2, "Not_Spawn" = 3)) +
#   scale_shape_manual(values = c('1' = 16, '0' = 16, "Trend" = 32, "Spawn" = 32, "Not_Spawn" = 32)) +
#   ylim(c(ymin, ymax))
return(p)
}
temp_plots <- list()
for(i in temp_stations){
plot_data <- clack_data_temp %>% filter(Char_Name == "Temperature, water", MLocID == i)
p <- plot_temperature(plot_data, seaKen, i)
temp_plots[[i]] <- p
}
temp_plots[1]
temp_plots[2]
temp_plots[3]
data <- plot_data
if(station %in% seaKen$MLocID){
slope <- seaKen[seaKen$MLocID == station & seaKen$Char_Name == "Temperature, water", "slope"]
x_min <- min(data$sample_datetime, na.rm = TRUE)
x_max <- max(data$sample_datetime, na.rm = TRUE)
x_delta <- as.numeric((x_max-x_min)/2)
y_median <- median(data$Result_Numeric, na.rm = TRUE)
sk_min <- y_median - x_delta*slope/365.25
sk_max <- y_median + x_delta*slope/365.25
}
ymin <- min(c(data$Result_Numeric, data$temp_crit), na.rm = TRUE)
ymax <- max(c(data$Result_Numeric, data$temp_crit), na.rm = TRUE)
data$excursion <- as.character(data$excursion)
p <- ggplot(data)
any(data$Spawn_type == "Spawn")
data$Start_spawn <- as.POSIXct(data$Start_spawn)
data$End_spawn <- as.POSIXct(data$End_spawn)
rects <- unique(data[,c("Start_spawn", "End_spawn")])
rects$ymin <- -Inf
rects$ymax <- Inf
p + geom_rect(data = rects, aes(xmin=Start_spawn, xmax=End_spawn, ymin=ymin, ymax=ymax), color = 'grey', alpha=.2, fill='black')
p <- p + geom_rect(data = rects, aes(xmin=Start_spawn, xmax=End_spawn, ymin=ymin, ymax=ymax), color = 'grey', alpha=.2, fill='black')
p <- p + geom_point(aes(x=sample_datetime, y=Result_Numeric, color = excursion, linetype = excursion, shape = excursion)) +
ggtitle(paste(station)) +
ylab("Temperature (degrees C)") +
xlab("Datetime")
p
if(station %in% seaKen$MLocID){
p <- p + geom_segment(aes(x=x_min, xend=x_max, y=sk_min, yend=sk_max, color = "Trend", linetype = "Trend", shape = "Trend"))
}
if(any(!is.na(data$temp_crit))){
p <- p + geom_line(aes(x=sample_datetime, y=temp_crit, color=Spawn_type, linetype=Spawn_type, shape=Spawn_type))
}
if(any(data$Spawn_type == "Spawn")){
p <- p + geom_line(aes(x=sample_datetime, y=spawning_crit, color=Spawn_type, linetype=Spawn_type, shape=Spawn_type))
}
p
p <- p +
scale_color_manual(values = c('1' = 'red', '0' = 'black', "Trend" = 'blue', "Spawn" = 'black', "Not_Spawn" = 'black')) +
scale_linetype_manual(values = c('1' = 0, '0' = 0, "Trend" = 1, "Spawn" = 2, "Not_Spawn" = 3)) +
scale_shape_manual(values = c('1' = 16, '0' = 16, "Trend" = 32, "Spawn" = 32, "Not_Spawn" = 32)) +
ylim(c(ymin, ymax))
p
plot_temperature <- function(data, seaKen, station){
if(station %in% seaKen$MLocID){
slope <- seaKen[seaKen$MLocID == station & seaKen$Char_Name == "Temperature, water", "slope"]
x_min <- min(data$sample_datetime, na.rm = TRUE)
x_max <- max(data$sample_datetime, na.rm = TRUE)
x_delta <- as.numeric((x_max-x_min)/2)
y_median <- median(data$Result_Numeric, na.rm = TRUE)
sk_min <- y_median - x_delta*slope/365.25
sk_max <- y_median + x_delta*slope/365.25
}
ymin <- min(c(data$Result_Numeric, data$temp_crit), na.rm = TRUE)
ymax <- max(c(data$Result_Numeric, data$temp_crit), na.rm = TRUE)
data$excursion <- as.character(data$excursion)
p <- ggplot(data)
if(any(data$Spawn_type == "Spawn")){
# spawn_start <- as.POSIXct(unique(data$spawn_start), format = "%m/%d")
# spawn_end <- as.POSIXct(unique(data$spawn_end), format = "%m/%d")
# years <- unique(lubridate::year(data$sample_datetime))
# rects <- data.frame(x1=as.POSIXct(paste0(years, "-", lubridate::month(spawn_start), "-", lubridate::day(spawn_start))),
#                     x2=as.POSIXct(paste0(years, "-", lubridate::month(spawn_end), "-", lubridate::day(spawn_end))),
#                     y1=-Inf, y2=Inf)
data$Start_spawn <- as.POSIXct(data$Start_spawn)
data$End_spawn <- as.POSIXct(data$End_spawn)
rects <- unique(data[,c("Start_spawn", "End_spawn")])
rects$ymin <- -Inf
rects$ymax <- Inf
p <- p + geom_rect(data = rects, aes(xmin=Start_spawn, xmax=End_spawn, ymin=ymin, ymax=ymax), color = 'grey', alpha=.15, fill='black')
}
p <- p + geom_point(aes(x=sample_datetime, y=Result_Numeric, color = excursion, linetype = excursion, shape = excursion)) +
ggtitle(paste(station)) +
ylab("Temperature (degrees C)") +
xlab("Datetime")
if(station %in% seaKen$MLocID){
p <- p + geom_segment(aes(x=x_min, xend=x_max, y=sk_min, yend=sk_max, color = "Trend", linetype = "Trend", shape = "Trend"))
}
if(any(!is.na(data$temp_crit))){
p <- p + geom_line(aes(x=sample_datetime, y=temp_crit, color="Non-Spawning", linetype="Non-Spawning", shape="Non-Spawning"))
}
if(any(data$Spawn_type == "Spawn")){
p <- p + geom_line(aes(x=sample_datetime, y=spawning_crit, color="Spawning", linetype="Spawning", shape="Spawning"))
}
p <- p +
scale_color_manual(values = c('1' = 'red', '0' = 'black', "Trend" = 'blue', "Spawning" = 'black', "Non-Spawning" = 'black')) +
scale_linetype_manual(values = c('1' = 0, '0' = 0, "Trend" = 1, "Spawning" = 2, "Non-Spawning" = 3)) +
scale_shape_manual(values = c('1' = 16, '0' = 16, "Trend" = 32, "Spawning" = 32, "Non-Spawning" = 32)) +
ylim(c(ymin, ymax))
return(p)
}
temp_plots <- list()
for(i in temp_stations){
plot_data <- clack_data_temp %>% filter(Char_Name == "Temperature, water", MLocID == i)
p <- plot_temperature(plot_data, seaKen, i)
temp_plots[[i]] <- p
}
temp_plots[1]
temp_plots[2]
View(plot_data)
View(clack_data_temp)
View(filter(clack_data_temp, year(SampleStartDate) == 2015))
View(filter(clack_data_temp, year(sample_datetime) == 2015))
View(filter(clack_data_temp, year(sample_datetime) == 2015), MLocID == 14210000)
View(filter(clack_data_temp, year(sample_datetime) == 2015, MLocID == 14210000))
temp_assessment <- function(df, datetime_column = "sample_datetime", spawn_start = "spawn_start", spawn_end = "spawn_end",
results = "Result_cen", criteria = "temp_crit"){
sample_datetime <- as.symbol(datetime_column)
spawn_start <- as.symbol(spawn_start)
spawn_end <- as.symbol(spawn_end)
results <- as.symbol(results)
criteria <- as.symbol(criteria)
temp_analysis <- df %>%
mutate(# Add columns for Critcal period start and end date
Crit_period_start = mdy(paste0("7/1/",year(sample_datetime))),
Cirt_period_end = mdy(paste0("9/30/",year(sample_datetime))),
# Append spawn start and end dates with year
Start_spawn = ifelse(!is.na(spawn_start), paste0(spawn_start,"/",year(sample_datetime)), NA ) ,
End_spawn = ifelse(!is.na(spawn_end), paste0(spawn_end,"/",year(sample_datetime)), NA ),
# Make spwnmn start and end date date format
Start_spawn = mdy(Start_spawn),
End_spawn = mdy(End_spawn),
# If Spawn dates span a calendar year, account for year change in spawn end date
End_spawn = if_else(End_spawn < Start_spawn & sample_datetime >= End_spawn, End_spawn + years(1), # add a year if in spawn period carrying to next year
End_spawn), # otherwise, keep End_spawn as current year
Start_spawn = ifelse(End_spawn < Start_spawn & sample_datetime <= Start_spawn, Start_spawn - years(1), # subtract a year if in spawn period carrying from previous year
Start_spawn) # otherwise, keep Start_spawn as current year
# SampleStartDate = ymd(sample_datetime),
# Flag for results in critical period
In_crit_period = ifelse(sample_datetime >=Crit_period_start & sample_datetime <= Cirt_period_end, 1, 0 ),
# Print if result is in spawn or out of spawn
Spawn_type = ifelse((sample_datetime >= Start_spawn & sample_datetime <= End_spawn & !is.na(Start_spawn)),  "Spawn", "Not_Spawn"),
# Flag if result does not attain standard,  use 13 for during spawn dates, else use criteria
excursion = ifelse(Spawn_type == "Spawn" & Result_cen > 13, 1,
ifelse(Spawn_type == "Not_Spawn" & Result_cen > criteria, 1, 0)),
# Flag for if excursion was in spawn period
Spawn_excursion = ifelse(Spawn_type == "Spawn" & excursion == 1, 1, 0 )
) %>%
arrange(sample_datetime)
# For each observation, determine the number of excursions within the last 3 years, the number of samples
# within the critical period, and the number of samples in the spawning period, all for the same station.
cat(paste("Checking within a 3 year period from sample date for the number of previous excursions",
"and the number of samples taken during spawning and critical periods...\n"))
temp_analysis <- bind_rows(
pbapply::pblapply(unique(temp_analysis$MLocID), function(x, df){
cat(paste("\nStation: ", x, "(", which(unique(df$MLocID) == x), "out of", length(unique(df$MLocID)), ")\n"))
subData <- filter(df, MLocID == x)
subData <- bind_cols(
subData,
dplyr::bind_rows(pbapply::pblapply(subData$sample_datetime,
function(x, df){
start3yr <- x - lubridate::years(3)
end3yr <- x
data <- dplyr::filter(df[,c(datetime_column, "excursion", "In_crit_period", "Spawn_type")],
dplyr::between(sample_datetime, start3yr, end3yr))
data <- dplyr::summarise(data,
n_excursions_3yr = sum(data$excursion),
samples_in_crit_period = sum(data$In_crit_period),
samples_in_spawn_period = sum(data$Spawn_type == "Spawn"))
return(data[, c("n_excursions_3yr", "samples_in_crit_period", "samples_in_spawn_period")])
},
df = subData[,c(datetime_column, "excursion", "In_crit_period", "Spawn_type")])
)
)
}, df = temp_analysis)
)
temp_analysis$excursion_cen <- ifelse(temp_analysis$excursion == 1 & temp_analysis$n_excursions_3yr >= 3, 1, 0)
temp_analysis$spawning_crit <- 13
return(temp_analysis)
}
clack_data_temp <- clack_data %>% filter(Char_Name == "Temperature, water")
clack_data_temp <- Censored_data(clack_data_temp, criteria = "temp_crit")
clack_data_temp <- temp_assessment(clack_data_temp)
temp_status <- status_stns(clack_data_temp)
temp_trend <- trend_stns(clack_data_temp)
seaKen <- sea_ken(filter(clack_data, MLocID %in% c(temp_trend$MLocID, pH_trend$MLocID)))
temp_stations <- unique(c(temp_status[temp_status$Char_Name == "Temperature, water",]$MLocID, seaKen[seaKen$Char_Name == "Temperature, water",]$MLocID))
temp_plots <- list()
for(i in temp_stations){
plot_data <- clack_data_temp %>% filter(Char_Name == "Temperature, water", MLocID == i)
p <- plot_temperature(plot_data, seaKen, i)
temp_plots[[i]] <- p
}
temp_plots[1]
View(rects)
temp_plots[2]
library(rgdal)
library(RODBC)
library(dplyr)
library(AWQMSdata)
# library(IRlibrary)
library(dataRetrieval)
library(ggplot2)
library(lubridate)
library(pbapply)
library(parallel)
start.date = "2000-01-01"
end.date = "2019-01-01"
Name <- "Clackamas"
# support_files_dir <- "//deqhq1/GISLIBRARY/Base_Data/Hydrography/Watershed_Boundaries/WBD_OR.gdb/WBD_OR.gdb/WBD_OR"
basin_shp <- readOGR(dsn = "//deqhq1/GISLIBRARY/Base_Data/Hydrography/Watershed_Boundaries/WBD_OR.gdb/WBD_OR.gdb",
layer = 'WBD_HU8', integer64="warn.loss", verbose = FALSE)
basin_shp <- basin_shp[basin_shp$HU_8_NAME == "Clackamas", ]
clack_stations_AWQMS <- get_stations_AWQMS(basin_shp)
devtools::install_github('https://github.com/donco/odeqstatusandtrends'
)
# devtools::install_github('https://github.com/donco/odeqstatusandtrends')
library(odeqstatusandtrends)
devtools::install_github('https://github.com/donco/odeqassessment')
# devtools::install_github('https://github.com/donco/odeqassessment')
library(odeqassessment)
clack_stations_AWQMS <- get_stations_AWQMS(basin_shp)
# ss_stations_NWIS <- get_stations_NWIS(agwqma_shp)
clack_data_raw <- GetData(parameters = c("Temperature", "Bacteria", "TSS", "DO", "TP", "pH"),
stations_AWQMS = clack_stations_AWQMS,
# stations_NWIS = ss_stations_NWIS,
start.date = start.date,
end.date = end.date)
clack_data <- CleanData(clack_data_raw)
clack_data <- add_criteria(clack_data)
clack_data_pH <- clack_data %>% filter(Char_Name == "pH")
clack_data_pH <- Censored_data(clack_data_pH, criteria = 'pH_Min')
clack_data_pH <- pH_assessment(clack_data_pH)
clack_data_temp <- clack_data %>% filter(Char_Name == "Temperature, water")
clack_data_temp <- Censored_data(clack_data_temp, criteria = "temp_crit")
clack_data_temp <- temp_assessment(clack_data_temp)
pH_status <- status_stns(clack_data_pH)
temp_status <- status_stns(clack_data_temp)
pH_trend <- trend_stns(clack_data_pH)
temp_trend <- trend_stns(clack_data_temp)
seaKen <- sea_ken(filter(clack_data, MLocID %in% c(temp_trend$MLocID, pH_trend$MLocID)))
temp_stations <- unique(c(temp_status[temp_status$Char_Name == "Temperature, water",]$MLocID, seaKen[seaKen$Char_Name == "Temperature, water",]$MLocID))
temp_plots <- list()
for(i in temp_stations){
plot_data <- clack_data_temp %>% filter(Char_Name == "Temperature, water", MLocID == i)
p <- plot_temperature(plot_data, seaKen, i)
temp_plots[[i]] <- p
}
temp_plots[2]
clack_data_pH <- clack_data %>% filter(Char_Name == "pH")
clack_data_pH <- Censored_data(clack_data_pH, criteria = 'pH_Min')
clack_data_pH <- pH_assessment(clack_data_pH)
pH_status <- status_stns(clack_data_pH)
View(clack_data_pH)
View(clack_data_pH)
pH_assessment <- function(pH_data) {
pH_summary <- pH_data %>%
mutate(pH_excursion = ifelse(Result_cen < pH_Min | Result_cen > pH_Max, 1, 0 ),
pH_excursion_high = ifelse(Result_cen > pH_Max, 1, 0 ),
pH_excursion_low = ifelse(Result_cen < pH_Min, 1, 0 )
)
pH_summary$excursion_cen <- pH_summary$pH_excursion
return(pH_summary)
}
clack_data_pH <- clack_data %>% filter(Char_Name == "pH")
clack_data_pH <- Censored_data(clack_data_pH, criteria = 'pH_Min')
clack_data_pH <- pH_assessment(clack_data_pH)
pH_status <- status_stns(clack_data_pH)
temp_status <- status_stns(clack_data_temp)
pH_trend <- trend_stns(clack_data_pH)
temp_trend <- trend_stns(clack_data_temp)
plot_temperature <- function(data, seaKen, station){
# obtain data range limits for plotting
xmin <- min(data$sample_datetime, na.rm = TRUE)
xmax <- max(data$sample_datetime, na.rm = TRUE)
ymin <- min(c(data$Result_Numeric, data$temp_crit), na.rm = TRUE)
ymax <- max(c(data$Result_Numeric, data$temp_crit), na.rm = TRUE)
data$excursion <- if_else(data$excursion == 1, "Excursion", "Result") # change numeric value to descriptor
# obtain plotting values for trend line if applicable
if(station %in% seaKen$MLocID){
slope <- seaKen[seaKen$MLocID == station & seaKen$Char_Name == "Temperature, water", "slope"]
x_delta <- as.numeric((xmax-xmin)/2)
y_median <- median(data$Result_Numeric, na.rm = TRUE)
sk_min <- y_median - x_delta*slope/365.25
sk_max <- y_median + x_delta*slope/365.25
}
p <- ggplot(data)
if(any(data$Spawn_type == "Spawn")){
# Convert spawning dates to datetimes
data$Start_spawn <- as.POSIXct(data$Start_spawn)
data$End_spawn <- as.POSIXct(data$End_spawn)
# create dataframe of spawning start/end dates, and relevant values for spawning zones and criteria lines
spawn_zones <- unique(data[,c("Start_spawn", "End_spawn")])
spawn_zones$next_start <- spawn_zones$Start_spawn + years(1)
spawn_zones$ymin <- -Inf
spawn_zones$ymax <- Inf
spawn_zones$temp_crit <- unique(data$temp_crit)
spawn_zones$spawn_crit <- 13
# adjust plot limits to allow for first and last spawning zones to plot
xmin <- min(xmin, min(spawn_zones$Start_spawn, na.rm = TRUE))
xmax <- max(xmax, max(spawn_zones$End_spawn, na.rm = TRUE))
# plot the shaded spawning zones
p <- p + geom_rect(data = spawn_zones, aes(xmin=Start_spawn, xmax=End_spawn, ymin=ymin, ymax=ymax,
# linetype = 'Spawning Zone', shape = 'Spawning Zone', color = 'Spawning Zone',
fill='Spawning Zone'),
color = NA, alpha=.15, show.legend = c(fill=TRUE, linetype=FALSE, shape=FALSE, color=FALSE))
# plot non-spawning criteria lines within non-spawning zones
p <- p + geom_segment(data = spawn_zones,
aes(x=End_spawn, xend=next_start, y=temp_crit, yend=temp_crit,
color="Non-Spawning", linetype="Non-Spawning", shape="Non-Spawning"),
size = 1)
# plot spawning criteria lines within spawning zones
p <- p + geom_segment(data = spawn_zones,
aes(x=Start_spawn, xend=End_spawn, y=spawn_crit, yend=spawn_crit,
color="Spawning", linetype="Spawning", shape="Spawning"),
size = 1)
} else if(any(!is.na(data$temp_crit))){
# plot non-spawining line across data if no spawning zones apply
p <- p + geom_line(aes(x=sample_datetime, y=temp_crit, color="Non-Spawning", linetype="Non-Spawning", shape="Non-Spawning"))
}
# plot data with excursion colors
p <- p + geom_point(aes(x=sample_datetime, y=Result_Numeric, color = excursion, linetype = excursion, shape = excursion)) +
ggtitle(paste(station)) +
ylab("Temperature (degrees C)") +
xlab("Datetime")
# plot the trend line if applicable
if(station %in% seaKen$MLocID){
p <- p + geom_segment(aes(x=xmin, xend=xmax, y=sk_min, yend=sk_max, color = "Trend", linetype = "Trend", shape = "Trend"))
}
# apply color, shape, line types, and range limits
p <- p +
scale_color_manual(name = "Legend",
values =    c('Excursion' = 'red', 'Result' = 'black', "Trend" = 'blue', "Spawning" = 'black', "Non-Spawning" = 'black')) +
scale_linetype_manual(name = "Legend",
values = c('Excursion' = 0, 'Result' = 0, "Trend" = 1, "Spawning" = 2, "Non-Spawning" = 1)) +
scale_shape_manual(name = "Legend",
values =    c('Excursion' = 16, 'Result' = 16, "Trend" = 32, "Spawning" = 32, "Non-Spawning" = 32)) +
scale_fill_manual(name = "", values = c("Spawning Zone" = 'black')) +
ylim(c(ymin, ymax)) +
xlim(c(xmin, xmax)) +
theme(legend.position="bottom", legend.direction = "horizontal", legend.box = "horizontal")
return(p)
}
seaKen <- sea_ken(filter(clack_data, MLocID %in% c(temp_trend$MLocID, pH_trend$MLocID)))
temp_stations <- unique(c(temp_status[temp_status$Char_Name == "Temperature, water",]$MLocID, seaKen[seaKen$Char_Name == "Temperature, water",]$MLocID))
temp_plots <- list()
for(i in temp_stations){
plot_data <- clack_data_temp %>% filter(Char_Name == "Temperature, water", MLocID == i)
p <- plot_temperature(plot_data, seaKen, i)
temp_plots[[i]] <- p
}
temp_plots[2]
devtools::install_github('https://github.com/donco/odeqstatusandtrends')
# devtools::install_github('https://github.com/donco/odeqstatusandtrends')
library(odeqstatusandtrends)
start.date = "2000-01-01"
end.date = "2019-01-01"
Name <- "Clackamas"
# support_files_dir <- "//deqhq1/GISLIBRARY/Base_Data/Hydrography/Watershed_Boundaries/WBD_OR.gdb/WBD_OR.gdb/WBD_OR"
basin_shp <- readOGR(dsn = "//deqhq1/GISLIBRARY/Base_Data/Hydrography/Watershed_Boundaries/WBD_OR.gdb/WBD_OR.gdb",
layer = 'WBD_HU8', integer64="warn.loss", verbose = FALSE)
basin_shp <- basin_shp[basin_shp$HU_8_NAME == "Clackamas", ]
clack_stations_AWQMS <- get_stations_AWQMS(basin_shp)
# ss_stations_NWIS <- get_stations_NWIS(agwqma_shp)
clack_data_raw <- GetData(parameters = c("Temperature", "Bacteria", "TSS", "DO", "TP", "pH"),
stations_AWQMS = clack_stations_AWQMS,
# stations_NWIS = ss_stations_NWIS,
start.date = start.date,
end.date = end.date)
clack_data <- CleanData(clack_data_raw)
clack_data <- add_criteria(clack_data)
clack_data_pH <- clack_data %>% filter(Char_Name == "pH")
clack_data_pH <- Censored_data(clack_data_pH, criteria = 'pH_Min')
clack_data_pH <- pH_assessment(clack_data_pH)
# clack_data_ph$exceed <- ifelse(clack_data_ph$Result_Numeric >= clack_data_ph$pH_crit_min & clack_data_ph$Result_Numeric <= clack_data_ph$pH_crit_max, FALSE, TRUE)
# clack_data_ph <- clack_data_ph %>% filter(!is.na(exceed))
clack_data_temp <- clack_data %>% filter(Char_Name == "Temperature, water")
clack_data_temp <- Censored_data(clack_data_temp, criteria = "temp_crit")
clack_data_temp <- temp_assessment(clack_data_temp)
pH_status <- status_stns(clack_data_pH)
temp_status <- status_stns(clack_data_temp)
pH_trend <- trend_stns(clack_data_pH)
temp_trend <- trend_stns(clack_data_temp)
seaKen <- sea_ken(filter(clack_data, MLocID %in% c(temp_trend$MLocID, pH_trend$MLocID)))
temp_stations <- unique(c(temp_status[temp_status$Char_Name == "Temperature, water",]$MLocID, seaKen[seaKen$Char_Name == "Temperature, water",]$MLocID))
temp_plots <- list()
for(i in temp_stations){
plot_data <- clack_data_temp %>% filter(Char_Name == "Temperature, water", MLocID == i)
p <- plot_temperature(plot_data, seaKen, i)
temp_plots[[i]] <- p
}
temp_plots[2]
getwd()
setwd('//deqhq1/WQNPS/Agriculture/Status_and_Trend_Analysis/StatusAndTrends_Package/odeqstatusandtrends')
getwd()
document()
library(devtools)
devtools::document()
devtools::document()
devtools::install_github('https://github.com/donco/odeqstatusandtrends')
